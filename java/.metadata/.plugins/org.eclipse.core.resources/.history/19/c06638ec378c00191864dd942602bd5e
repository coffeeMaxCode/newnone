package part5;

import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;

public class T01_AddressBook extends JFrame implements ActionListener {
			
		 T02_SubBook subBook = null;
		 static T01_AddressBook aBook = null;
		 JPanel jp_north = new JPanel();
		 JButton jbtn_ins = new JButton("입력");
		 JButton jbtn_upd = new JButton("수정");
		 JButton jbtn_del = new JButton("삭제");
		 JButton jbtn_det = new JButton("상세조회");
		 //헤더 정보 담을 객체 추가
		 String cols[] = {"아이디","이름","주소","HP"};
		 String data[][] = new String[0][4];
		 //데이터를 담을 수 있는 클래스가 필요
		 //data set
		 DefaultTableModel dtm_address = new DefaultTableModel(data,cols);
		 //화면,그리드 만 제공 데이터 없음 
		 JTable jt_address = new JTable(dtm_address);
		 JScrollPane jsp_address = new JScrollPane(jt_address);
		 JTableHeader jth_address = jt_address.getTableHeader();
		 
 public void initDisplay() {
	 	  //내안에 있을 때는 this 외부에 있을 떄는 인스턴스 변수
	 jbtn_ins.addActionListener(this);
	 jbtn_upd.addActionListener(this);
	 jbtn_det.addActionListener(this);

	 jp_north.setLayout(new FlowLayout());

	 jp_north.add(jbtn_ins);
	 jp_north.add(jbtn_upd);
	 jp_north.add(jbtn_del);
	 jp_north.add(jbtn_det);
	 this.add("North",jp_north);
	 this.add("Center",jsp_address);
	 this.setSize(700, 500);
	 this.setVisible(true);
	 jth_address.setFont(new Font("맑은고딕",Font.BOLD,18));
	 jth_address.setBackground(new Color(22,22,100));
	 jth_address.setForeground(Color.white);
	 jth_address.setReorderingAllowed(false);
	 jth_address.setResizingAllowed(false);
	 jt_address.setGridColor(Color.blue);
	 jt_address.getColumnModel().getColumn(0).setPreferredWidth(80);
	 jt_address.getColumnModel().getColumn(1).setPreferredWidth(100);
	 jt_address.getColumnModel().getColumn(2).setPreferredWidth(390);
	 jt_address.getColumnModel().getColumn(3).setPreferredWidth(130);
	 jt_address.repaint();
		  
 }
 
 //새로고침 처리 메소드 구현
 	public void refreshData() {
 		System.out.println("새로고침처리");
 }

 	
	 public static void main(String[] args) {//인스턴스화처리 ->메모리상주
	  if(aBook==null) {
	   aBook = new T01_AddressBook();
	  }
	  aBook.initDisplay();
	 }
	
	 @Override
	 public void actionPerformed(ActionEvent ae) {//이벤트 감지
     String label = ae.getActionCommand();//버튼의 라벨을 읽어올 수 있음.
     	if("입력".equals(label)) {
     		subBook = null;
     		subBook = new T02_SubBook();
     		subBook.set(null, label,aBook,true);//set호출
     		
			  }else if("수정".equals(label)) {
			   subBook = null;
			   subBook = new T02_SubBook();
			   subBook.set(new T03_AddressVO(), label,aBook,true);
			   
			   subBook.setVisible(true);
			   
			  }else if("상세조회".equals(label)){
				  subBook = null;
				  subBook = new T02_SubBook();
				  //문제제기- 어!! 화면그리는 메소드가 사라졌네?
				  subBook.set(new T03_AddressVO(), label,aBook,false);
			
  }
  
 }


	 
}
 
/*********************************************
 * 1)
 * A a = NEW a();
 * a = null;
 * a = new A();
 * 이벤트 처리할 때 마다 추가
 * 선언부에서 선언만 하고 - 전변으로 선언
 * 생성은 이벤트 처리시 마다 생성
 * 
 * 객체를 인스턴스화 할 때 주의사항
 * 무조건 전역변수 위치에서 인스턴스화 하는 것이 좋은 건 아니다.
 * 
 * A a = new A();
 * 
 * A a = null;
 * a = new A();
 * 
 * 그 객체가 필요할 때 주입되는 것이 효율적이다.
 * 객체가 협업이 필요할 때 같은 메소드를 반복해서 호출하는 것은 피해야 한다. -stackoverflow 일어날 가능성 높음.
 * ->해결방법
 * 메소드 중심의 코딩을 한다.
 * -> * 반복되는 코드를 줄일 수 있다.
 * 
 * 입력 
 * 입력은 새로 입력받아야 함
 * insert를 해야 되는 경우임.
 * 
 * 수정 
 * 수정은 기존에 가지고 있는 정보를 변경하는 것
 * 수정의 경우 기본 정보를 보여주는 경우가 대부분이므로 select를 먼저하고
 * 화면을 보여주어야하지 않을까?
 * update를 해야 되는 경우임
 * 
 * 상세조회
 * 상세조회는
 * 기존에 가입된 사람의 정보를 조회하는 것
 * select를 해야 되는 경우임 
 * 
 * 세가지 메뉴를 하나의 화면에서 처리할 때 - 문제발생
 * 
 * 등록하는 화면 추가
 *
 * 
 * 
 * 2)
 * set 메소드 추가
 * set(AddressBook aBook, String title)
 * main() - AddressBook 인스턴스화처리 - 메모리상주
 * 버튼클릭(입력,수정,상세조회) -이벤트 감지
 * actionPerformed호출- 자식창 호출(set 호출)
 * SubBook의 initDisplay()가 호출이 안됨.
 * 생성자에서 호출했다.
 * subBook.initDisplay();
 * subBook.setTitle(label);
 * 
 * 문제제기
 * 실제로 생성된 객체는 하나이지만 메소드콜이 일어날 때 마다
 * (initDisplay) 객체가 여러개 복제되는
 * 일이 일어남.
 *********************************************/

/******************************************
 * 생성자 호출 - 순서 - 처리 
 * 
 * 해결 - 메소드
 * set(aBook,title,boolean,   )
 * 
 * 
*/////////////////////////////////////////////////